"""
This pre-processor parses a single file containing a list of
MP_CONST_FLOAT items.

These are used to generate a header with the required entries.
"""

import argparse
import io
import math
import re
import struct
import sys

from textwrap import dedent

PATTERN = re.compile(r"MP_CONST_FLOAT_[_0-9a-zA-Z]+")


def find_constant_floats(filename):
    """Find any MP_CONST_FLOAT definitions in the provided file.

    :param str filename: path to file to check
    :return: List[variable_declaration]
    """
    with io.open(filename, encoding="utf-8") as c_file_obj:
        content = c_file_obj.read()
        return set(re.findall(PATTERN, content))


def cast(from_, to, value):
    return struct.unpack(to, struct.pack(from_, value))[0]


def removeprefix(s, pfx):  # assumes s starts with pfx
    return s[len(pfx) :]


repr_e_bias = 0x30080000
repr_e_roll = 3


def roll32_l(val, n):
    return ((val << n) | (val >> (32 - n))) & 0xFFFFFFFF


def generate_constant_float_definition(constant_name):
    expression = removeprefix(constant_name, "MP_CONST_FLOAT_")
    if expression.startswith("__"):
        expression = "-" + expression[2:]
    expression = expression.replace("__", ".")
    value = eval(expression, math.__dict__)
    if expression == "inf":
        c_value = "INFINITY"
    elif expression == "-inf":
        c_value = "-INFINITY"
    elif expression == "nan":
        c_value = "NAN"
    elif expression == "-0":
        c_value = "-0."
    else:
        c_value = float(value)

    print(f"// {constant_name} = {value}")
    double_as_uint64 = cast("d", "Q", value)
    repr_d_value = double_as_uint64 + 0x8004000000000000
    float_as_uint32 = cast("f", "I", value)
    repr_c_value = ((((float_as_uint32) & ~3) | 2) + 0x80800000) & 0xFFFFFFFF
    repr_e_value = roll32_l((float_as_uint32 + repr_e_bias) & 0xFFFFFFFF, repr_e_roll)

    print(
        dedent(f"""\
        #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B
        extern const struct _mp_obj_float_t {constant_name}_obj;
        #define {constant_name} MP_ROM_PTR(&{constant_name}_obj)
        #if defined(MP_FLOAT_CONSTS_IMPL)
        const mp_obj_float_t {constant_name}_obj = {{ {{&mp_type_float}}, (mp_float_t)({c_value}) }};
        #endif
        #elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D
        #define {constant_name} {{ ((mp_obj_t)((uint64_t){repr_d_value:#x})) }}
        #elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
        #define {constant_name} ((mp_obj_t)((uint64_t){repr_c_value:#x}))
        #else // REPR_E""")
    )

    if repr_e_value & 0x3 == 3:
        print(f"#define {constant_name} ((mp_obj_t)((uint64_t){repr_e_value:#x}))")
    else:
        print(
            dedent(f"""\
            extern const struct _mp_obj_float_t {constant_name}_obj;
            #define {constant_name} MP_ROM_PTR(&{constant_name}_obj)
            #if defined(MP_FLOAT_CONSTS_IMPL)
            const mp_obj_float_t {constant_name}_obj = {{ {{&mp_type_float}}, (mp_float_t)({c_value}) }};
            #endif""")
        )

    print("""#endif""")
    print()


def generate_constant_float_header(constant_floats):
    """Generate header with root pointer entries.

    :param List[variable_declaration] constant_floats: root pointer declarations
    :return: None
    """

    # Print header file for all external modules.
    print(
        dedent("""\
    // Automatically generated by make_constant_floats.py.
    #ifndef MICROPY_INCLUDED_FLOAT_CONSTS_H
    #define MICROPY_INCLUDED_FLOAT_CONSTS_H
    """)
    )

    for item in constant_floats:
        generate_constant_float_definition(item)

    print("#endif")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("file", nargs=1, help="file with MP_CONST_FLOAT definitions")
    args = parser.parse_args()

    constant_floats = find_constant_floats(args.file[0])
    generate_constant_float_header(sorted(constant_floats))


if __name__ == "__main__":
    main()
