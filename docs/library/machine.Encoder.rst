.. currentmodule:: machine
.. _machine.Encoder:

class Encoder -- quadrature decoding
====================================

Encoder implements decoding of quadrature signals as commonly output from
rotary encoders, by counting either up or down depending on the order of two
input pulses.

Minimal example usage::

    from machine import Pin, Encoder

    counter = Counter(0, Pin(0, Pin.IN), Pin(1, Pin.IN))   # create Encoder for pins 0, 1 and begin counting
    value = counter.value()                                # retrieve current count

Availability: **ESP32**

Constructors
------------

.. class:: Encoder(id, ...)

   Returns the singleton Encoder object for the the given *id*. Values of *id*
   depend on a particular port and its hardware. Values 0, 1, etc. are commonly
   used to select hardware block #0, #1, etc.

   Additional arguments are passed to the :meth:`init` method described below,
   and will cause the Encoder instance to be re-initialised and reset.

   On ESP32, the *id* corresponds to a :ref:`PCNT unit <esp32.PCNT>`.

Methods
-------

.. method:: Encoder.init(phase_a, phase_b, *, ...)

   Initialise and reset the Encoder with the given parameters:

   - *phase_a* specifies the first input pin as a
     :ref:`machine.Pin <machine.Pin>` object.

   - *phase_b* specifies the second input pin as a
     :ref:`machine.Pin <machine.Pin>` object.

   These pins may be omitted on ports that have predefined pins for a given
   hardware block.

   Additional keyword-only parameters that may be supported by a port are:

   - *filter_ns* specifies a minimum period of time in nanoseconds that the
     source signal needs to be stable for a pulse to be counted. Implementations
     should use the longest filter supported by the hardware that is less than
     or equal to this value. The default is 0 (no filter). *(Supported on ESP32 and MIMXRT)*

   - *phases* specifies the number of signal edges to count and thus the
     granularity of the decoding. e.g. 4 phases corresponds to "4x quadrature
     decoding", and will result in four counts per pulse. Ports may support
     either 1, 2, or 4 phases and the default is 1 phase. *(Supported on ESP32 and MIMXRT)*

   - *cpc*\=value. Specify the number of counts per cycle. Since the MIMXRT 
     Encoder hardware counts all four phases of the input signal, the cpc value has to be four
     times the ppr value given in the encoder data sheet. The position counter will count up
     from the 0 up to cpc - 1, and then reset to the init value of 0 and increase
     the cycles counter by one. The default is: no cpc set. In that case the
     position counter overflows at 2**32 - 1. When counting down, the cycles counter changes
     at the transition from 0 to cpc - 1. *(Supported on MIMXRT)*
 
   - *signed*\=False|True tells, whether the value return by Encoder.value() is signed or
     unsigned. The default is ``True``. *(Supported on MIMXRT)*
 
   - *index*\=value. A Pin specifier telling to which pin the index pulse is connected.
     At a rising slope of the index pulse the position counter is set to the init value
     and the cycles counter is increased by one. A *value* of *None* disables the index input.
     *(Supported on MIMXRT)*
 
   - *home*\=value. A Pin specifier telling to which pin the home pulse is connected.
     At a rising slope of the home pulse the position counter is set to the init
     value, but the cycles counter is not changed. A *value* of *None* disables the home input.
     *(Supported on MIMXRT)*
 
   - *match_pin*\=value. A Pin specifier telling to which pin the match output is connected.
     This output will have a high level as long as the position counter matches the
     match value. The signal is generated by the encoder logic and requires no
     further software support. The pulse width is defined by the input signal frequency
     and can be very short, like 20ns, or stay, if the counter stops at the match position.
     A *value* of *None* disables the match output. *(Supported on MIMXRT)*

.. method:: Encoder.deinit()

   Stops the Encoder, disabling any interrupts and releasing hardware resources.
   A Soft Reset should deinitialize all Encoder objects.

.. method:: Encoder.value([value])

   Get, and optionally set, the encoder value as a signed integer.
   Implementations should aim to do the get and set atomically.

   See :meth:`machine.Counter.value` for details about overflow of this value.

.. method:: cycles=Encoder.cycles([value])

   Get or set the current cycles counter of the Encoder as signed 16 bit integer.

   With no arguments the actual cycles counter value is returned.

   With a single *value* argument the cycles counter is set to that value. The
   position counter is not changed. The methods returns the previous value.
   *(Supported on MIMXRT)*

   If the value returned by Encoder.value() is unsigned,
   the total position can be calculated as cycles() * cpc + value().
   If the total position range is still too small, you can create your own cycles
   counter using the irq() callback method.

.. method:: Encoder.irq(trigger=event, value=nnn, handler=handler, hard=False)

   Specifies, that the *handler* is called when the respective *event* happens.

   *event* may be:
    - Encoder.IRQ_MATCH Triggered when the position counter matches the match value.
    - Encoder.IRQ_ROLL_OVER Triggered when the position counter rolls over from the highest
      to the lowest value.
    - Encoder.IRQ_ROLL_UNDER Triggered when the position counter rolls under from the lowest
      to the highest value.

   The callback is called, when the Encoder is at *value*. For fast signals, the actual counter
   value may be different from the trigger value.
   The callback function *handler* receives a single argument, which is the Encoder object. All
   events share the same callback. The event which triggers the callback can be identified
   with the Encoder.status() method. The argument *hard* specifies, whether the callback is called
   as a hard interrupt or as regular scheduled function. Hard interrupts have always a short latency,
   but are limited in that they must not allocate memory. Regular scheduled functions are not limited
   in what can be used, but depending on the load of the device execution may be delayed.
   Under low load, the difference in latency is minor.

   The default arguments values are trigger=0, handler=None, hard=False. The callback will be
   disabled, when called with handler=None.

   The position match event is triggered as long as the position and match value are identical.
   Therefore the position match callback is run in a one-shot fashion, and has to be enabled
   again when the position has changed. *(Supported on MIMXRT)*

.. method:: Encoder.status()

   Returns the event status flags of the recent handled Encoder interrupt as a bitmap.
   The assignment of events to the bits are:

   - 0: Transition at the HOME signal. (*)
   - 1: Transition at the INDEX signal. (*)
   - 2: Watchdog event. (*)
   - 3 or Encoder.IRQ_MATCH: Position match event.
   - 4: Phase_A and Phase_B changed at the same time. (*)
   - 5 or Encoder.IRQ_ROLL_OVER: Roll-Over event of the counter.
   - 6 or Encoder.IRQ_ROLL_UNDER: Roll-Under event of the counter.
   - 7: Direction of the last count. 1 for counting up, 0 for counting down.

   (*) These flags are defined, but not (yet) enabled.
   *(Supported on MIMXRT)*

.. method:: Encoder.id()

   Return the id of the Encoder. That may be helpful for interrupt callback
   functions. *(Supported on MIMXRT)*

Constants
---------

.. data:: Encoder.IRQ_COMPARE  
          Encoder.IRQ_ROLL_OVER   
          Encoder.IRQ_ROLL_UNDER  

   Select the IRQ trigger event.  *(Supported on MIMXRT)*
