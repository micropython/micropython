.. currentmodule:: machine
.. _machine.Counter:

class Counter -- pulse counter
==============================

Counter implements pulse counting by monitoring an input signal and counting
rising or falling edges.

Minimal example usage::

    from machine import Pin, Counter

    counter = Counter(0, Pin(0, Pin.IN))  # create Counter for pin 0 and begin counting
    value = counter.value()               # retrieve current pulse count

Availability: **ESP32**

Constructors
------------

.. class:: Counter(id, ...)

   Returns the singleton Counter object for the the given *id*. Values of *id*
   depend on a particular port and its hardware. Values 0, 1, etc. are commonly
   used to select hardware block #0, #1, etc.

   Additional arguments are passed to the :meth:`init` method described below,
   and will cause the Counter instance to be re-initialised and reset.

   On ESP32, the *id* corresponds to a :ref:`PCNT unit <esp32.PCNT>`.

Methods
-------

.. method:: Counter.init(src, *, ...)

   Initialise and reset the Counter with the given parameters:

   - *src* specifies the input pin as a :ref:`machine.Pin <machine.Pin>` object.
     May be omitted on ports that have a predefined pin for a given hardware
     block.

   Additional keyword-only parameters that may be supported by a port are:

   - *edge* specifies the edge to count. Either ``Counter.RISING`` (the default)
     or ``Counter.FALLING``. *(Supported on ESP32)*

   - *direction* specifies the direction to count. Either ``Counter.UP`` (the
     default) or ``Counter.DOWN``. *(Supported on ESP32 and MIMXRT)*
     A :ref:`machine.Pin <machine.Pin>` object as parameter argument specifies a
     pin which controls the counting direction. Low: Count up, High: Count down.
     *(Supported on MIMXRT)*

   - *filter_ns* specifies a minimum period of time in nanoseconds that the
     source signal needs to be stable for a pulse to be counted. Implementations
     should use the longest filter supported by the hardware that is less than
     or equal to this value. The default is 0 (no filter). *(Supported on ESP32)*
 
   - *match_pin*\=value. A Pin specifier telling to which pin the match output is connected.
     This output will have a high level as long as the counter value
     matches the match value. The signal is generated by the encoder logic and
     requires no further software support.  A *value* of *None* disables the match output.
     *(Supported on MIMXRT)*

   - *cpc*\=value. Specify the number of counts per cycle.The counter will count up
     from the 0 up to cpc - 1, and then reset to 0 and increase
     the cycles counter by one. The default is: no cpc set. In that case the
     counter overflows at 2**32 - 1. If the counting direction is DOWN, then the cycles
     counter is decreased when counting from 0 to cpc-1. *(Supported on MIMXRT)*

   - *signed*\=False|True tells, whether the value returned by Counter.value() is signed or
     unsigned. The default is ``True``. *(Supported on MIMXRT)*

   - *index*\=value. A Pin specifier telling to which pin the index pulse is connected.
     At a rising slope of the index pulse the counter is set to 0
     and the cycles counter is increased by one. A *value* of *None* disables the index input.
     *(Supported on MIMXRT)*

.. method:: Counter.deinit()

   Stops the Counter, disabling any interrupts and releasing hardware resources.
   A Soft Reset should deinitialize all Counter objects.

.. method:: Counter.value([value])

   Get, and optionally set, the counter value as a signed integer.
   Implementations must aim to do the get and set atomically (i.e. without
   leading to skipped counts).

   This counter value could exceed the range of a :term:`small integer`, which
   means that calling :meth:`Counter.value` could cause a heap allocation, but
   implementations should aim to ensure that internal state only uses small
   integers and therefore will not allocate until the user calls
   :meth:`Counter.value`.

   For example, on ESP32, the internal state counts overflows of the hardware
   counter (every 32000 counts), which means that it will not exceed the small
   integer range until ``2**30 * 32000`` counts (slightly over 1 year at 1MHz).

   In general, it is recommended that you should use ``Counter.value(0)`` to reset
   the counter (i.e. to measure the counts since the last call), and this will
   avoid this problem.

.. method:: cycles=Counter.cycles([value])

   Get or set the current cycles counter of the counter as signed 16 bit integer.
   The value represents the overflow or underflow events of the 32bit basic counter.
   A total count can be calculated as cycles() * 0x100000000 + value().
   If the total count range is still too small, you can create your own overflow
   counter using the irq() callback method.

   With no arguments the actual cycles counter value is returned.

   With a single *value* argument the cycles counter is set to that value. The
   base counter is not changed. The methods returns the previous value.
   *(Supported on MIMXRT)*

.. method:: Counter.irq(trigger=event, value=nnn, handler=handler, hard=False)

   Specifies, that the *handler* is called when the respective *event* happens.

   *event* may be:
    - Counter.IRQ_COMPARE Triggered when the positions counter matches the match value.
    - Counter.IRQ_ROLL_OVER Triggered when the position counter rolls over from the highest
      to the lowest value.
    - Counter.IRQ_ROLL_UNDER Triggered when the position counter rolls under from the lowest
      to the highest value.

   The callback is called, when the Counter is at *value*. For fast signals, the actual counter
   value may be different from the trigger value.
   The callback function *handler* receives a single argument, which is the Counter object. All
   events share the same callback. The event which triggers the callback can be identified
   with the Counter.status() method. The argument *hard* specifies, whether the callback is called
   as a hard interrupt or as regular scheduled function. Hard interrupts have always a short latency,
   but are limited in that they must not allocate memory. Regular scheduled functions are not limited
   in what can be used, but depending on the load of the device execution may be delayed.
   Under low load, the difference in latency is minor.

   The default arguments values are trigger=0, handler=None, hard=False. The callback will be
   disabled, when called with handler=None.

   The counter match event is triggered as long as the lower 32 bit of the counter and match
   value match. Therefore the counter match callback is run in a one-shot fashion, and has to be enabled
   again when the counter value has changed. *(Supported on MIMXRT)*

.. method:: Counter.status()

   Returns the event status flags of the recent handled Counter interrupt as a bitmap.
   The assignment of events to the bits are:

   - 0: Transition at the HOME signal. (*)
   - 1: Transition at the INDEX signal. (*)
   - 2: Watchdog event. (*)
   - 3 or Counter.IRQ_MATCH: Position match event.
   - 4: Phase_A and Phase_B changed at the same time. (*)
   - 5 or Counter.IRQ_ROLL_OVER: Roll-Over event of the counter.
   - 6 or Counter.IRQ_ROLL_UNDER: Roll-Under event of the counter.
   - 7: Direction of the last count. 1 for counting up, 0 for counting down.

   (*) These flags are defined, but not (yet) enabled.  

   *(Supported on MIMXRT)*

.. method:: Counter.id()

   Return the id of the Counter. That may be helpful for interrupt callback functions.
   *(Supported on MIMXRT)*

Constants
---------

.. data:: Counter.RISING
          Counter.FALLING

   Select the pulse edge. *(Supported on ESP32)*

.. data:: Counter.UP
          Counter.DOWN

   Select the counting direction.

.. data:: Counter.IRQ_COMPARE  
          Counter.IRQ_ROLL_OVER   
          Counter.IRQ_ROLL_UNDER  

   Select the IRQ trigger event.  *(Supported on MIMXRT)*

